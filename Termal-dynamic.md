这是一份可以直接交给算法工程师执行的LGT (Latent Geometric Thermodynamics) 模型架构设计说明书。这份设计完全贯彻了我们之前的理论验证结论：内容是刚性的拓扑（SSM），风格是流动的分布（SWD），动力学需要热涨落（Langevin）。LGT 模型架构设计说明书 (Version 1.0)目标硬件: NVIDIA RTX 4070 Laptop (8GB VRAM)输入数据: VAE Latent ($4 \times 32 \times 32$)核心任务: 在潜空间流形上，通过最小化几何自由能实现风格迁移。模块一：势能定义 (The Energy Landscape)这是整个系统的核心。我们不再优化 MSE，而是优化“几何自由能”。请工程师严格按照以下数学定义实现 Loss。1.1 风格势能：Patch-Sliced Wasserstein Distance (Patch-SWD)设计意图：解决 VAE 4 通道信息量不足的问题。通过提取 $3\times3$ Patch，将 4 维特征升维到 36 维纹理空间，并在此高维空间做分布对齐。输入：x_pred: 模型预测的终态 Latent $[B, 4, H, W]$x_style: 目标风格参考 Latent $[B, 4, H, W]$操作步骤：Unfold (升维): 使用 F.unfold(k=3, pad=1) 将 Latent 展开为 $[B, N_{patches}, 36]$。这里 $36 = 4 \times 3 \times 3$。Sampling (蒙特卡洛): 为了显存优化，从 $B \times N_{patches}$ 中随机采样 4096 个点。Projection (Radon变换): 生成随机投影向量 $\theta \in \mathbb{R}^{36 \times 64}$ (64为投影数)。计算投影 $P = X \cdot \theta$。Sorting (分位数对齐): 对投影后的标量进行排序。Metric: 计算排序后序列的 MSE。1.2 内容势能：Cosine Self-Similarity Matrix (Cosine-SSM)设计意图：利用余弦相似度的“幅度不变性”，锁死特征点之间的拓扑夹角，允许风格带来的数值缩放。输入：x_pred: 模型预测的终态 Latentx_src: 源内容 Latent操作步骤：Reshape: $[B, 4, H, W] \to [B, 4, N]$。Normalize (关键): 对 Channel 维度做 $L_2$ 归一化。$z \leftarrow z / ||z||_2$。这一步消除了颜色/强度的影响。Gram Matrix: 计算 $A = z^T z$ (形状 $[B, N, N]$)。Metric: 计算 $||A_{pred} - A_{src}||_F^2$。模块二：动力学算子 (The Model Architecture)我们需要一个能够执行“分布变换”的算子。传统的卷积（权重固定）是静态的，无法根据 Style ID 动态扭曲特征分布。我们引入 Dynamic Convolution (HyperNetworks)。2.1 核心组件：Style Dynamic Conv (SDC)这是一个“根据风格生成卷积核”的模块。结构定义：Input: 特征图 $x$，风格嵌入 $e_{style}$。HyperNet: 一个线性层 Linear(style_dim, in_channels * kernel_size^2)。Operation:HyperNet 输出权重 $W_{dyn}$。Reshape $W_{dyn}$ 为 Depthwise Conv 格式 $[C, 1, K, K]$。对 $x$ 执行 F.conv2d(x, W_dyn, groups=C)。物理意义：每个风格对应一套独特的“空间滤波器”。梵高的滤波器可能倾向于产生旋转的纹理，莫奈的滤波器倾向于模糊边界。2.2 整体架构：LGT-UNet采用轻量级 U-Net 结构，制造物理瓶颈（Bottleneck）以强制重构纹理。Encoder (结构提取):常规 ResBlock。下采样到 $8 \times 8$。不使用 Dynamic Conv (因为我们需要提取客观的结构)。Bottleneck:$8 \times 8$ 分辨率。这里高频纹理已丢失，只剩语义骨架。Decoder (纹理生成):全部使用 Style Dynamic Conv 替代标准卷积。这是风格注入发生的地方。模型必须利用动态核，从语义骨架中“生长”出新的纹理分布。模块三：热力学推理 (Thermodynamic Inference)推理过程不再是简单的 ODE 积分，而是 Langevin 修正的 Euler 积分。3.1 算法流程给定源 Latent $z_0$ (由 Inversion 得到) 和目标风格 $s$。对于 $t$ 从 0 到 1 (步数 $N=20$)：Drift (漂移): 计算确定性速度 $v = \text{Model}(z_t, t, s)$。Diffusion (扩散): 采样高斯噪声 $\epsilon \sim \mathcal{N}(0, I)$。Update (更新):$$z_{t+1} = z_t + v \cdot dt + \sigma(t) \cdot \sqrt{dt} \cdot \epsilon$$3.2 温度调度 $\sigma(t)$前期 ($t < 0.5$): $\sigma = 0$。此时主要在恢复大的轮廓结构，不需要噪声干扰。后期 ($t > 0.5$): $\sigma = \lambda$。此时开始生成细碎的纹理，需要热涨落帮助模型跳出平滑解，生成高频细节。模块四：针对 4070 Laptop 的工程约束请在代码实现中强制加入以下约束：显存防火墙:Patch-SWD 计算量随 Patch 数量平方增长。必须在 Loss 内部限制采样点数 max_samples=4096。不要对全图计算。算力优化:Dynamic Conv 必须使用 Depthwise (groups=in_channels)。如果使用全连接卷积，参数量会爆炸，推理会很慢。精度管理:模型推理用 BFloat16。但是，SWD 的排序操作 (torch.sort) 和 SSM 的矩阵乘法 (torch.bmm) 必须在 Float32 下进行，否则梯度会数值不稳定。给开发者的执行摘要 (Checklist)[ ] Loss: 实现 SlicedWassersteinLoss，包含 unfold 和 randperm 采样。[ ] Loss: 实现 CosineSSMLoss，记得先做 F.normalize(dim=1)。[ ] Model: 实现 StyleDynamicConv，使用 groups=channels。[ ] Model: 搭建 LGT-UNet，Encoder 用普通 Conv，Decoder 用 Dynamic Conv。[ ] Train: 在 Loss 计算时，不再使用 MSE($v, v_{gt}$)，而是计算 $E_{total}(\hat{z}_1)$。[ ] Inference: 在 Euler 积分步骤中加入 noise * temperature 项。这个方案已经通过了理论验证，请严格照此执行。